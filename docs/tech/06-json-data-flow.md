# JSON Data Interchange

## 1. Overview
The communication between our React Frontend and Python Backend is strictly typed using JSON (JavaScript Object Notation). This ensures that the evaluation pipeline is deterministic and easy to debug.

## 2. API Contract

### Endpoint: `POST /evaluate`

#### Request Schema
The backend expects strictly this format. Any deviation triggers a `422 Unprocessable Entity` error from Pydantic.

```json
{
  "query": "Who is the CEO of Google?",
  "response": "Sundar Pichai is the CEO of Google.",
  "context": [
    "Google's CEO is Sundar Pichai.",
    "He assumed the role in 2015."
  ]
}
```

*   **query** (string): The user's input question.
*   **response** (string): The text generated by the LLM.
*   **context** (List[string]): A list of ground-truth snippets retrieved from a Vector DB.

---

#### Response Schema
The backend returns a comprehensive report including scores and a verdict.

```json
{
  "metrics": {
    "relevance": 0.92,
    "completeness": 1.0,
    "hallucination": 0.0,
    "latency_ms": 45.2,
    "cost_usd": 0.0001
  },
  "verdict": {
    "status": "PASS",
    "reasons": [
      "High relevance score",
      "No hallucinations detected"
    ]
  }
}
```

*   **metrics**: Raw numerical scores (0.0 - 1.0).
*   **verdict**: A logic-based decision.
    *   `PASS`: If Relevance > 0.7 AND Hallucination < 0.2.
    *   `FAIL`: Otherwise.

---

## 3. Sample Data Structure
The application supports uploading complex JSON files, which are processed client-side before being sent to the API.

### Chat Conversation (`conversation.json`)
The source of the `Query` and `Response`.
```json
{
    "conversation_turns": [
        { "role": "User", "message": "My query..." },
        { "role": "AI/Chatbot", "message": "My response..." }
    ]
}
```

### Vector Data (`context.json`)
The source of the `Context`.
```json
{
    "data": {
        "vector_data": [
            { "text": "Context snippet 1..." },
            { "text": "Context snippet 2..." }
        ]
    }
}
```
